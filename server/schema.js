const pool = require("./pool");

module.exports = {
  async init() {
    const client = await pool.pool.connect();
    try {
      /*await client.query(`
CREATE TABLE IF NOT EXISTS sessions (
session_id INT PRIMARY KEY GENERATED BY DEFAULT AS IDENTITY,
session_uuid CHAR(36) NOT NULL,
create_date TIMESTAMP(3) NOT NULL DEFAULT NOW()
);

CREATE TABLE IF NOT EXISTS users (
user_id INT PRIMARY KEY GENERATED BY DEFAULT AS IDENTITY,
display_name VARCHAR(50),
display_name_index INT DEFAULT 0,
email VARCHAR(255),
password_hash BYTEA,
admin BOOL DEFAULT false,
create_date TIMESTAMP(3) NOT NULL DEFAULT NOW()
);

CREATE TABLE IF NOT EXISTS user_sessions (
user_id INT NOT NULL,
session_id INT NOT NULL,
create_date TIMESTAMP(3) NOT NULL DEFAULT NOW(),
PRIMARY KEY (user_id, session_id)
);

CREATE TABLE IF NOT EXISTS reset_tokens (
token_id INT PRIMARY KEY GENERATED BY DEFAULT AS IDENTITY,
user_id INT NOT NULL,
token_uuid CHAR(36) NOT NULL,
create_date TIMESTAMP(3) NOT NULL DEFAULT NOW()
);

CREATE TABLE IF NOT EXISTS topics (
topic_id INT PRIMARY KEY GENERATED BY DEFAULT AS IDENTITY,
title VARCHAR(140),
body VARCHAR(8000),
note VARCHAR(500),
slug VARCHAR(140),
comment_count INT DEFAULT 0,
comment_count_max_create_date TIMESTAMP(3) NOT NULL DEFAULT NOW(),
user_id INT NOT NULL,
admin BOOL DEFAULT false,
create_date TIMESTAMP(3) NOT NULL DEFAULT NOW()
);
CREATE INDEX idx_topics_create_date ON topics(create_date);
CREATE INDEX idx_topics_create_date_comment_count_max_create_date 
ON topics(create_date, comment_count_max_create_date)
STORING (comment_count);

CREATE TABLE IF NOT EXISTS comments (
comment_id INT PRIMARY KEY GENERATED BY DEFAULT AS IDENTITY,
parent_topic_id INT,
parent_comment_id INT,
body VARCHAR(1000),
note VARCHAR(500),
user_id INT NOT NULL,
create_date TIMESTAMP(3) NOT NULL DEFAULT NOW()
);
CREATE INDEX idx_comments_create_date ON comments(create_date);
CREATE INDEX idx_comments_parent_comment_id ON comments(parent_comment_id);
CREATE INDEX idx_comments_parent_topic_id ON comments(parent_topic_id);

CREATE TABLE IF NOT EXISTS comment_ancestors (
comment_id INT NOT NULL,
ancestor_id INT NOT NULL
);
CREATE INDEX idx_comment_ancestor ON comment_ancestors (comment_id, ancestor_id);
ALTER TABLE comment_ancestors
ADD CONSTRAINT unique_comment_ancestor UNIQUE (comment_id, ancestor_id);

CREATE TABLE IF NOT EXISTS topic_images (
topic_image_id INT PRIMARY KEY GENERATED BY DEFAULT AS IDENTITY,
topic_id INT NOT NULL,
image_uuid CHAR(36) NOT NULL,
create_date TIMESTAMP(3) NOT NULL DEFAULT NOW()
);
CREATE INDEX idx_topic_images_topic_id ON topic_images(topic_id) STORING (image_uuid);

CREATE TABLE IF NOT EXISTS comment_images (
comment_image_id INT PRIMARY KEY GENERATED BY DEFAULT AS IDENTITY,
comment_id INT NOT NULL,
image_uuid CHAR(36) NOT NULL,
create_date TIMESTAMP(3) NOT NULL DEFAULT NOW()
);
CREATE INDEX idx_comment_images_comment_id ON comment_images(comment_id) STORING (image_uuid);

CREATE TABLE IF NOT EXISTS subscriptions (
subscription_id INT PRIMARY KEY GENERATED BY DEFAULT AS IDENTITY,
user_id INT NOT NULL,
subscription_json VARCHAR(1024),
fcm_token VARCHAR(1024),
active BOOL DEFAULT true,
create_date TIMESTAMP(3) NOT NULL DEFAULT NOW()
);
CREATE INDEX idx_subscriptions_user_id ON subscriptions(user_id) STORING (subscription_json);

CREATE TABLE IF NOT EXISTS notifications (
notification_id INT PRIMARY KEY GENERATED BY DEFAULT AS IDENTITY,
user_id INT NOT NULL,
comment_id INT,
read BOOL DEFAULT false,
seen BOOL DEFAULT false,
create_date TIMESTAMP(3) NOT NULL DEFAULT NOW()
);
CREATE INDEX idx_notifications_user_id_create_date_read_seen ON notifications(user_id, create_date, read, seen);
CREATE INDEX idx_notifications_comment_id ON notifications(comment_id);

      `);*/
      // const tables = ["users", "sessions", "user_sessions", "articles", "comments", "comment_ancestors", "comment_images", "article_images", "notifications", "subscriptions"];
      // for (const table of tables) {
      //   await client.query(`USE defaultdb;`);
      //   const original = await client.query(`
      //     SELECT * FROM ${table};
      //   `);
      //   await client.query(`USE fca;`);
      //   let new_table_name = table.replace("article", "topic");
      //   // await client.query(`DELETE FROM ${new_table_name};`);
      //   const before = await client.query(`
      //     SELECT * FROM ${new_table_name};
      //   `);
      //   // for (const row of original.rows) {
      //   //   delete row.votes_raw;
      //   //   delete row.votes_weighted;
      //   //   delete row.parent_topic_paragraph_index;
      //   //   await client.query(
      //   //     `
      //   //     INSERT INTO ${new_table_name} (${Object.keys(row).map(k=>k.replace("article", "topic")).join(", ")})
      //   //     VALUES (${Object.values(row).map((v, i) => `$${i + 1}`)})
      //   //   `,
      //   //     Object.keys(row).map((k) => row[k]),
      //   //   );
      //   // }
      //   const after = await client.query(`
      //     SELECT * FROM ${new_table_name};
      //   `);
      //   console.log(new_table_name, original.rows.length, before.rows.length, after.rows.length);
      // }
      // SELECT setval('sessions_session_id_seq', (SELECT MAX(session_id) FROM sessions) + 1);
      // SELECT setval('users_user_id_seq', (SELECT MAX(user_id) FROM users) + 1);
      // SELECT setval('topics_topic_id_seq', (SELECT MAX(topic_id) FROM topics) + 1);
      // SELECT setval('comments_comment_id_seq', (SELECT MAX(comment_id) FROM comments) + 1);
      // SELECT setval('comment_images_comment_image_id_seq', (SELECT MAX(comment_image_id) FROM comment_images) + 1);
      // SELECT setval('topic_images_topic_image_id_seq', (SELECT MAX(topic_image_id) FROM topic_images) + 1);
      // SELECT setval('notifications_notification_id_seq', (SELECT MAX(notification_id) FROM notifications) + 1);
      // SELECT setval('subscriptions_subscription_id_seq', (SELECT MAX(subscription_id) FROM subscriptions) + 1);
      // SELECT setval('reset_tokens_token_id_seq', (SELECT MAX(token_id) FROM reset_tokens) + 1);
      
    } catch (err) {
      console.error("error executing query:", err);
    } finally {
      client.release();
    }
  },
};
